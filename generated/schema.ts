// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
	TypedMap,
	Entity,
	Value,
	ValueKind,
	store,
	Bytes,
	BigInt,
	BigDecimal,
} from "@graphprotocol/graph-ts";

export class MerchatWalletCreated extends Entity {
	constructor(id: Bytes) {
		super();
		this.set("id", Value.fromBytes(id));
	}

	save(): void {
		let id = this.get("id");
		assert(
			id != null,
			"Cannot save MerchatWalletCreated entity without an ID"
		);
		if (id) {
			assert(
				id.kind == ValueKind.BYTES,
				`Entities of type MerchatWalletCreated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
			);
			store.set("MerchatWalletCreated", id.toBytes().toHexString(), this);
		}
	}

	static load(id: Bytes): MerchatWalletCreated | null {
		return changetype<MerchatWalletCreated | null>(
			store.get("MerchatWalletCreated", id.toHexString())
		);
	}

	get id(): Bytes {
		let value = this.get("id");
		return value!.toBytes();
	}

	set id(value: Bytes) {
		this.set("id", Value.fromBytes(value));
	}

	get merchantAddress(): Bytes {
		let value = this.get("merchantAddress");
		return value!.toBytes();
	}

	set merchantAddress(value: Bytes) {
		this.set("merchantAddress", Value.fromBytes(value));
	}

	get merchantWallet(): Bytes {
		let value = this.get("merchantWallet");
		return value!.toBytes();
	}

	set merchantWallet(value: Bytes) {
		this.set("merchantWallet", Value.fromBytes(value));
	}

	get blockNumber(): BigInt {
		let value = this.get("blockNumber");
		return value!.toBigInt();
	}

	set blockNumber(value: BigInt) {
		this.set("blockNumber", Value.fromBigInt(value));
	}

	get blockTimestamp(): BigInt {
		let value = this.get("blockTimestamp");
		return value!.toBigInt();
	}

	set blockTimestamp(value: BigInt) {
		this.set("blockTimestamp", Value.fromBigInt(value));
	}

	get transactionHash(): Bytes {
		let value = this.get("transactionHash");
		return value!.toBytes();
	}

	set transactionHash(value: Bytes) {
		this.set("transactionHash", Value.fromBytes(value));
	}
}

export class OwnershipTransferred extends Entity {
	constructor(id: Bytes) {
		super();
		this.set("id", Value.fromBytes(id));
	}

	save(): void {
		let id = this.get("id");
		assert(
			id != null,
			"Cannot save OwnershipTransferred entity without an ID"
		);
		if (id) {
			assert(
				id.kind == ValueKind.BYTES,
				`Entities of type OwnershipTransferred must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
			);
			store.set("OwnershipTransferred", id.toBytes().toHexString(), this);
		}
	}

	static load(id: Bytes): OwnershipTransferred | null {
		return changetype<OwnershipTransferred | null>(
			store.get("OwnershipTransferred", id.toHexString())
		);
	}

	get id(): Bytes {
		let value = this.get("id");
		return value!.toBytes();
	}

	set id(value: Bytes) {
		this.set("id", Value.fromBytes(value));
	}

	get previousOwner(): Bytes {
		let value = this.get("previousOwner");
		return value!.toBytes();
	}

	set previousOwner(value: Bytes) {
		this.set("previousOwner", Value.fromBytes(value));
	}

	get newOwner(): Bytes {
		let value = this.get("newOwner");
		return value!.toBytes();
	}

	set newOwner(value: Bytes) {
		this.set("newOwner", Value.fromBytes(value));
	}

	get blockNumber(): BigInt {
		let value = this.get("blockNumber");
		return value!.toBigInt();
	}

	set blockNumber(value: BigInt) {
		this.set("blockNumber", Value.fromBigInt(value));
	}

	get blockTimestamp(): BigInt {
		let value = this.get("blockTimestamp");
		return value!.toBigInt();
	}

	set blockTimestamp(value: BigInt) {
		this.set("blockTimestamp", Value.fromBigInt(value));
	}

	get transactionHash(): Bytes {
		let value = this.get("transactionHash");
		return value!.toBytes();
	}

	set transactionHash(value: Bytes) {
		this.set("transactionHash", Value.fromBytes(value));
	}
}

export class PaymentRecieved extends Entity {
	constructor(id: Bytes) {
		super();
		this.set("id", Value.fromBytes(id));
	}

	save(): void {
		let id = this.get("id");
		assert(id != null, "Cannot save PaymentRecieved entity without an ID");
		if (id) {
			assert(
				id.kind == ValueKind.BYTES,
				`Entities of type PaymentRecieved must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
			);
			store.set("PaymentRecieved", id.toBytes().toHexString(), this);
		}
	}

	static load(id: Bytes): PaymentRecieved | null {
		return changetype<PaymentRecieved | null>(
			store.get("PaymentRecieved", id.toHexString())
		);
	}

	get id(): Bytes {
		let value = this.get("id");
		return value!.toBytes();
	}

	set id(value: Bytes) {
		this.set("id", Value.fromBytes(value));
	}

	get orderId(): string {
		let value = this.get("orderId");
		return value!.toString();
	}

	set orderId(value: string) {
		this.set("orderId", Value.fromString(value));
	}

	get amount(): BigInt {
		let value = this.get("amount");
		return value!.toBigInt();
	}

	set amount(value: BigInt) {
		this.set("amount", Value.fromBigInt(value));
	}

	get sender(): Bytes {
		let value = this.get("sender");
		return value!.toBytes();
	}

	set sender(value: Bytes) {
		this.set("sender", Value.fromBytes(value));
	}

	get merchantWallet(): Bytes {
		let value = this.get("merchantWallet");
		return value!.toBytes();
	}

	set merchantWallet(value: Bytes) {
		this.set("merchantWallet", Value.fromBytes(value));
	}

	get blockNumber(): BigInt {
		let value = this.get("blockNumber");
		return value!.toBigInt();
	}

	set blockNumber(value: BigInt) {
		this.set("blockNumber", Value.fromBigInt(value));
	}

	get blockTimestamp(): BigInt {
		let value = this.get("blockTimestamp");
		return value!.toBigInt();
	}

	set blockTimestamp(value: BigInt) {
		this.set("blockTimestamp", Value.fromBigInt(value));
	}

	get transactionHash(): Bytes {
		let value = this.get("transactionHash");
		return value!.toBytes();
	}

	set transactionHash(value: Bytes) {
		this.set("transactionHash", Value.fromBytes(value));
	}
}
